{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-09-17T02:46:09.564Z","updated":"2020-09-17T02:46:09.564Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-09-17T02:46:09.566Z","updated":"2020-09-17T02:46:09.566Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-09-17T02:46:09.566Z","updated":"2020-09-17T02:46:09.566Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-09-17T02:46:09.567Z","updated":"2020-09-17T02:46:09.567Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-09-17T02:46:09.566Z","updated":"2020-09-17T02:46:09.566Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-09-17T02:46:09.567Z","updated":"2020-09-17T02:46:09.567Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-09-17T02:46:09.568Z","updated":"2020-09-17T02:46:09.568Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"simpread-(8 条消息)Arthas - Java 线上问题定位处理的终极利器_未读代码 - CSDN 博客","date":"2020-09-17T02:31:12.528Z","updated":"2020-09-15T01:24:20.523Z","comments":true,"path":"2020/09/17/simpread-(8 条消息)Arthas - Java 线上问题定位处理的终极利器_未读代码 - CSDN 博客/","link":"","permalink":"http://example.com/2020/09/17/simpread-(8%20%E6%9D%A1%E6%B6%88%E6%81%AF)Arthas%20-%20Java%20%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E5%A4%84%E7%90%86%E7%9A%84%E7%BB%88%E6%9E%81%E5%88%A9%E5%99%A8_%E6%9C%AA%E8%AF%BB%E4%BB%A3%E7%A0%81%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"&gt; 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/u013735734/article/details/102930307) 前言在使用 Arthas 之前，当遇到 Java 线上问题时，如 CPU 飙升、负载突高、内存溢出等问题，你需要查命令，查网络，然后 jps、jstack、jmap、jhat、jstat、hprof 等一通操作。最终焦头烂额，还不一定能查出问题所在。而现在，大多数的常见问题你都可以使用 Arthas 轻松定位，迅速解决，及时止损，准时下班。 1、Arthas 介绍Arthas 是 Alibaba 在 2018 年 9 月开源的 Java 诊断工具。支持 JDK6+， 采用命令行交互模式，提供 Tab 自动不全，可以方便的定位和诊断线上程序运行问题。截至本篇文章编写时，已经收获 Star 17000+。 Arthas 官方文档十分详细，本文也参考了官方文档内容，同时在开源在的 Github 的项目里的 Issues 里不仅有问题反馈，更有大量的使用案例，也可以进行学习参考。 开源地址：https://github.com/alibaba/arthas 官方文档：https://alibaba.github.io/arthas 2、Arthas 使用场景得益于 Arthas 强大且丰富的功能，让 Arthas 能做的事情超乎想象。下面仅仅列举几项常见的使用情况，更多的使用场景可以在熟悉了 Arthas 之后自行探索。 是否有一个全局视角来查看系统的运行状况？ 为什么 CPU 又升高了，到底是哪里占用了 CPU ？ 运行的多线程有死锁吗？有阻塞吗？ 程序运行耗时很长，是哪里耗时比较长呢？如何监测呢？ 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 有什么办法可以监控到 JVM 的实时运行状态？ 3、Arthas 怎么用前文已经提到，Arthas 是一款命令行交互模式的 Java 诊断工具，由于是 Java 编写，所以可以直接下载相应 的 jar 包运行。 3.1 安装可以在官方 Github 上进行下载，如果速度较慢，可以尝试国内的码云 Gitee 下载。 123456\\# github下载wget https:&#x2F;&#x2F;alibaba.github.io&#x2F;arthas&#x2F;arthas-boot.jar# 或者 Gitee 下载wget https:&#x2F;&#x2F;arthas.gitee.io&#x2F;arthas-boot.jar# 打印帮助信息java -jar arthas-boot.jar -h 3.2 运行Arthas 只是一个 java 程序，所以可以直接用 java -jar 运行。运行时或者运行之后要选择要监测的 Java 进程。 123456789101112\\# 运行方式1，先运行，在选择 Java 进程 PIDjava -jar arthas-boot.jar# 选择进程(输入\\[\\]内编号(不是PID)回车)\\[INFO\\] arthas-boot version: 3.1.4\\[INFO\\] Found existing java process, please choose one and hit RETURN.\\* \\[1\\]: 11616 com.Arthas \\[2\\]: 8676 \\[3\\]: 16200 org.jetbrains.jps.cmdline.Launcher \\[4\\]: 21032 org.jetbrains.idea.maven.server.RemoteMavenServer# 运行方式2，运行时选择 Java 进程 PIDjava -jar arthas-boot.jar \\[PID\\] 查看 PID 的方式可以通过 ps 命令，也可以通过 JDK 提供的 jps命令。 1234\\# 查看运行的 java 进程信息$ jps -mlvV # 筛选 java 进程信息$ jps -mlvV | grep \\[xxx\\] jps 筛选想要的进程方式。 在出现 Arthas Logo 之后就可以使用命令进行问题诊断了。下面会详细介绍。 更多的启动方式可以参考 help 帮助命令。 12345678910111213141516\\# 其他用法EXAMPLES: java -jar arthas-boot.jar &lt;pid&gt; java -jar arthas-boot.jar --target-ip 0.0.0.0 java -jar arthas-boot.jar --telnet-port 9999 --http-port -1 java -jar arthas-boot.jar --tunnel-server &#39;ws:&#x2F;&#x2F;192.168.10.11:7777&#x2F;ws&#39; java -jar arthas-boot.jar --tunnel-server &#39;ws:&#x2F;&#x2F;192.168.10.11:7777&#x2F;ws&#39;--agent-id bvDOe8XbTM2pQWjF4cfw java -jar arthas-boot.jar --stat-url &#39;http:&#x2F;&#x2F;192.168.10.11:8080&#x2F;api&#x2F;stat&#39; java -jar arthas-boot.jar -c &#39;sysprop; thread&#39; &lt;pid&gt; java -jar arthas-boot.jar -f batch.as &lt;pid&gt; java -jar arthas-boot.jar --use-version 3.1.4 java -jar arthas-boot.jar --versions java -jar arthas-boot.jar --session-timeout 3600 java -jar arthas-boot.jar --attach-only java -jar arthas-boot.jar --repo-mirror aliyun --use-http 3.3 web consoleArthas 目前支持 Web Console，在成功启动连接进程之后就已经自动启动，可以直接访问 http://127.0.0.1:8563/ 访问，页面上的操作模式和控制台完全一样。 3.4 常用命令下面列举一些 Arthas 的常用命令，看到这里你可能还不知道怎么使用，别急，后面会一一介绍。 命令介绍dashboard当前系统的实时数据面板thread查看当前 JVM 的线程堆栈信息watch方法执行数据观测trace方法内部调用路径，并输出方法路径上的每个节点上耗时stack输出当前方法被调用的调用路径tt方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测monitor方法执行监控jvm查看当前 JVM 信息vmoption查看，更新 JVM 诊断相关的参数sc查看 JVM 已加载的类信息sm查看已加载类的方法信息jad反编译指定已加载类的源码classloader查看 classloader 的继承树，urls，类加载信息heapdump类似 jmap 命令的 heap dump 功能 3.5 退出使用 shutdown 退出时 Arthas 同时自动重置所有增强过的类 。 4、Arthas 常用操作上面已经了解了什么是 Arthas，以及 Arthas 的启动方式，下面会依据一些情况，详细说一说 Arthas 的使用方式。在使用命令的过程中如果有问题，每个命令都可以是 -h 查看帮助信息。 首先编写一个有各种情况的测试类运行起来，再使用 Arthas 进行问题定位， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144import java.util.HashSet;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import lombok.extern.slf4j.Slf4j;&#x2F;\\*\\* \\* &lt;p&gt; \\* Arthas Demo \\* 公众号：未读代码 \\* \\* @Author niujinpeng \\*&#x2F;@Slf4jpublic class Arthas &#123; private static HashSet hashSet &#x3D; new HashSet(); &#x2F;\\*\\* 线程池，大小1\\*&#x2F; private static ExecutorService executorService &#x3D; Executors.newFixedThreadPool(1); public static void main(String\\[\\] args) &#123; &#x2F;&#x2F; 模拟 CPU 过高，这里注释掉了，测试时可以打开 &#x2F;&#x2F; cpu(); &#x2F;&#x2F; 模拟线程阻塞 thread(); &#x2F;&#x2F; 模拟线程死锁 deadThread(); &#x2F;&#x2F; 不断的向 hashSet 集合增加数据 addHashSetThread(); &#125; &#x2F;\\*\\* \\* 不断的向 hashSet 集合添加数据 \\*&#x2F; public static void addHashSetThread() &#123; &#x2F;&#x2F; 初始化常量 new Thread(() -&gt; &#123; int count &#x3D; 0; while (true) &#123; try &#123; hashSet.add(&quot;count&quot; + count); Thread.sleep(10000); count++; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; public static void cpu() &#123; cpuHigh(); cpuNormal(); &#125; &#x2F;\\*\\* \\* 极度消耗CPU的线程 \\*&#x2F; private static void cpuHigh() &#123; Thread thread &#x3D; new Thread(() -&gt; &#123; while (true) &#123; log.info(&quot;cpu start 100&quot;); &#125; &#125;); &#x2F;&#x2F; 添加到线程 executorService.submit(thread); &#125; &#x2F;\\*\\* \\* 普通消耗CPU的线程 \\*&#x2F; private static void cpuNormal() &#123; for (int i &#x3D; 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; while (true) &#123; log.info(&quot;cpu start&quot;); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125; &#x2F;\\*\\* \\* 模拟线程阻塞,向已经满了的线程池提交线程 \\*&#x2F; private static void thread() &#123; Thread thread &#x3D; new Thread(() -&gt; &#123; while (true) &#123; log.debug(&quot;thread start&quot;); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#x2F;&#x2F; 添加到线程 executorService.submit(thread); &#125; &#x2F;\\*\\* \\* 死锁 \\*&#x2F; private static void deadThread() &#123; &#x2F;\\*\\* 创建资源 \\*&#x2F; Object resourceA &#x3D; new Object(); Object resourceB &#x3D; new Object(); &#x2F;&#x2F; 创建线程 Thread threadA &#x3D; new Thread(() -&gt; &#123; synchronized (resourceA) &#123; log.info(Thread.currentThread() + &quot; get ResourceA&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.info(Thread.currentThread() + &quot;waiting get resourceB&quot;); synchronized (resourceB) &#123; log.info(Thread.currentThread() + &quot; get resourceB&quot;); &#125; &#125; &#125;); Thread threadB &#x3D; new Thread(() -&gt; &#123; synchronized (resourceB) &#123; log.info(Thread.currentThread() + &quot; get ResourceB&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.info(Thread.currentThread() + &quot;waiting get resourceA&quot;); synchronized (resourceA) &#123; log.info(Thread.currentThread() + &quot; get resourceA&quot;); &#125; &#125; &#125;); threadA.start(); threadB.start(); &#125;&#125; 4.1 全局监控使用 dashboard 命令可以概览程序的 线程、内存、GC、运行环境信息。 4.2 CPU 为什么起飞了上面的代码例子有一个 CPU 空转的死循环，非常的消耗 CPU性能，那么怎么找出来呢？ 使用 thread 查看所有线程信息，同时会列出每个线程的 CPU 使用率，可以看到图里 ID 为 12 的线程 CPU 使用 100%。 使用命令 thread 12 查看 CPU 消耗较高的 12 号线程信息，可以看到 CPU 使用较高的方法和行数（这里的行数可能和上面代码里的行数有区别，因为上面的代码在我写文章时候重新排过版了）。 上面是先通过观察总体的线程信息，然后查看具体的线程运行情况。如果只是为了寻找 CPU 使用较高的线程，可以直接使用命令 thread -n [显示的线程个数] ，就可以排列出 CPU 使用率 Top N 的线程。 定位到的 CPU 使用最高的方法。 4.3 线程池线程状态定位线程问题之前，先回顾一下线程的几种常见状态： RUNNABLE 运行中 TIMED_WAITIN 调用了以下方法的线程会进入 TIMED_WAITING： Thread#sleep() Object#wait() 并加了超时参数 Thread#join() 并加了超时参数 LockSupport#parkNanos() LockSupport#parkUntil() WAITING 当线程调用以下方法时会进入 WAITING 状态： Object#wait() 而且不加超时参数 Thread#join() 而且不加超时参数 LockSupport#park() BLOCKED 阻塞，等待锁 上面的模拟代码里，定义了线程池大小为 1 的线程池，然后在 cpuHigh 方法里提交了一个线程，在 thread方法再次提交了一个线程，后面的这个线程因为线程池已满，会阻塞下来。 使用 thread | grep pool 命令查看线程池里线程信息。 可以看到线程池有 WAITING 的线程。 4.4 线程死锁上面的模拟代码里 deadThread方法实现了一个死锁，使用 thread -b 命令查看直接定位到死锁信息。 12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;\\*\\* \\* 死锁 \\*&#x2F;private static void deadThread() &#123; &#x2F;\\*\\* 创建资源 \\*&#x2F; Object resourceA &#x3D; new Object(); Object resourceB &#x3D; new Object(); &#x2F;&#x2F; 创建线程 Thread threadA &#x3D; new Thread(() -&gt; &#123; synchronized (resourceA) &#123; log.info(Thread.currentThread() + &quot; get ResourceA&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.info(Thread.currentThread() + &quot;waiting get resourceB&quot;); synchronized (resourceB) &#123; log.info(Thread.currentThread() + &quot; get resourceB&quot;); &#125; &#125; &#125;); Thread threadB &#x3D; new Thread(() -&gt; &#123; synchronized (resourceB) &#123; log.info(Thread.currentThread() + &quot; get ResourceB&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.info(Thread.currentThread() + &quot;waiting get resourceA&quot;); synchronized (resourceA) &#123; log.info(Thread.currentThread() + &quot; get resourceA&quot;); &#125; &#125; &#125;); threadA.start(); threadB.start();&#125; 检查到的死锁信息。 4.5 反编译上面的代码放到了包 com下，假设这是一个线程环境，当怀疑当前运行的代码不是自己想要的代码时，可以直接反编译出代码，也可以选择性的查看类的字段或方法信息。 如果怀疑不是自己的代码，可以使用 jad 命令直接反编译 class。 jad 命令还提供了一些其他参数： 1234\\# 反编译只显示源码jad --source-only com.Arthas# 反编译某个类的某个方法jad --source-only com.Arthas mysql 4.6 查看字段信息使用 **sc -d -f ** 命令查看类的字段信息。 1234567891011121314151617181920212223242526272829303132333435363738394041\\[arthas@20252\\]$ sc -d -f com.Arthassc -d -f com.Arthas class-info com.Arthas code-source &#x2F;C:&#x2F;Users&#x2F;Niu&#x2F;Desktop&#x2F;arthas&#x2F;target&#x2F;classes&#x2F; name com.Arthas isInterface false isAnnotation false isEnum false isAnonymousClass false isArray false isLocalClass false isMemberClass false isPrimitive false isSynthetic false simple-name Arthas modifier public annotation interfaces super-class +-java.lang.Object class-loader +-sun.misc.Launcher$AppClassLoader@18b4aac2 +-sun.misc.Launcher$ExtClassLoader@2ef1e4fa classLoaderHash 18b4aac2 fields modifierfinal,private,static type org.slf4j.Logger name log value Logger\\[com.Arthas\\] modifierprivate,static type java.util.HashSet name hashSet value \\[count1, count2\\] modifierprivate,static type java.util.concurrent.ExecutorService name executorService value java.util.concurrent.ThreadPoolExecutor@71c03156\\[Ru nning, pool size &#x3D; 1, active threads &#x3D; 1, queued ta sks &#x3D; 0, completed tasks &#x3D; 0\\]Affect(row-cnt:1) cost in 9 ms. 4.7 查看方法信息使用 sm 命令查看类的方法信息。 12345678910111213141516\\[arthas@22180\\]$ sm com.Arthascom.Arthas &lt;init&gt;()Vcom.Arthas start()Vcom.Arthas thread()Vcom.Arthas deadThread()Vcom.Arthas lambda$cpuHigh$1()Vcom.Arthas cpuHigh()Vcom.Arthas lambda$thread$3()Vcom.Arthas addHashSetThread()Vcom.Arthas cpuNormal()Vcom.Arthas cpu()Vcom.Arthas lambda$addHashSetThread$0()Vcom.Arthas lambda$deadThread$4(Ljava&#x2F;lang&#x2F;Object;Ljava&#x2F;lang&#x2F;Object;)Vcom.Arthas lambda$deadThread$5(Ljava&#x2F;lang&#x2F;Object;Ljava&#x2F;lang&#x2F;Object;)Vcom.Arthas lambda$cpuNormal$2()VAffect(row-cnt:16) cost in 6 ms. 4.8 对变量的值很是好奇使用 ognl 命令，ognl 表达式可以轻松操作想要的信息。 代码还是上面的示例代码，我们查看变量 hashSet 中的数据： 查看静态变量 hashSet 信息。 1234567891011121314\\[arthas@19856\\]$ ognl &#39;@com.Arthas@hashSet&#39;@HashSet\\[ @String\\[count1\\], @String\\[count2\\], @String\\[count29\\], @String\\[count28\\], @String\\[count0\\], @String\\[count27\\], @String\\[count5\\], @String\\[count26\\], @String\\[count6\\], @String\\[count25\\], @String\\[count3\\], @String\\[count24\\], 查看静态变量 hashSet 大小。 12\\[arthas@19856\\]$ ognl &#39;@com.Arthas@hashSet.size()&#39; @Integer\\[57\\] 甚至可以进行操作。 1234567\\[arthas@19856\\]$ ognl &#39;@com.Arthas@hashSet.add(&quot;test&quot;)&#39; @Boolean\\[true\\]\\[arthas@19856\\]$# 查看添加的字符\\[arthas@19856\\]$ ognl &#39;@com.Arthas@hashSet&#39; | grep test @String\\[test\\],\\[arthas@19856\\]$ ognl 可以做很多事情，可以参考 ognl 表达式特殊用法 (https://github.com/alibaba/arthas/issues/71)。 4.9 程序有没有问题4.9.1 运行较慢、耗时较长使用 trace 命令可以跟踪统计方法耗时 这次换一个模拟代码。一个最基础的 Springboot 项目（当然，不想 Springboot 的话，你也可以直接在 UserController 里 main 方法启动）控制层 getUser 方法调用了 userService.get(uid);，这个方法中分别进行check、service、redis、mysql操作。 1234567891011121314151617@RestController@Slf4jpublic class UserController &#123; @Autowired private UserServiceImpl userService; @GetMapping(value &#x3D; &quot;&#x2F;user&quot;) public HashMap&lt;String, Object&gt; getUser(Integer uid) throws Exception &#123; &#x2F;&#x2F; 模拟用户查询 userService.get(uid); HashMap&lt;String, Object&gt; hashMap &#x3D; new HashMap&lt;&gt;(); hashMap.put(&quot;uid&quot;, uid); hashMap.put(&quot;name&quot;, &quot;name&quot; + uid); return hashMap; &#125;&#125; 模拟代码 Service: 12345678910111213141516171819202122232425262728293031323334353637383940414243@Service@Slf4jpublic class UserServiceImpl &#123; public void get(Integer uid) throws Exception &#123; check(uid); service(uid); redis(uid); mysql(uid); &#125; public void service(Integer uid) throws Exception &#123; int count &#x3D; 0; for (int i &#x3D; 0; i &lt; 10; i++) &#123; count +&#x3D; i; &#125; log.info(&quot;service end &#123;&#125;&quot;, count); &#125; public void redis(Integer uid) throws Exception &#123; int count &#x3D; 0; for (int i &#x3D; 0; i &lt; 10000; i++) &#123; count +&#x3D; i; &#125; log.info(&quot;redis end &#123;&#125;&quot;, count); &#125; public void mysql(Integer uid) throws Exception &#123; long count &#x3D; 0; for (int i &#x3D; 0; i &lt; 10000000; i++) &#123; count +&#x3D; i; &#125; log.info(&quot;mysql end &#123;&#125;&quot;, count); &#125; public boolean check(Integer uid) throws Exception &#123; if (uid &#x3D;&#x3D; null || uid &lt; 0) &#123; log.error(&quot;uid不正确，uid:&#123;&#125;&quot;, uid); throw new Exception(&quot;uid不正确&quot;); &#125; return true; &#125;&#125; 运行 Springboot 之后，使用 **trace== ** 命令开始检测耗时情况。 1\\[arthas@6592\\]$ trace com.UserController getUser 访问接口 /getUser ，可以看到耗时信息，看到 com.UserServiceImpl:get()方法耗时较高。 继续跟踪耗时高的方法，然后再次访问。 1\\[arthas@6592\\]$ trace com.UserServiceImpl get 很清楚的看到是 com.UserServiceImpl的 mysql方法耗时是最高的。 1234567Affect(class-cnt:1 , method-cnt:1) cost in 31 ms.\\&#96;---ts&#x3D;2019-10-16 14:40:10;thread\\_name&#x3D;http-nio-8080-exec-8;id&#x3D;1f;is\\_daemon&#x3D;true;priority&#x3D;5;TCCL&#x3D;org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@23a918c7 \\&#96;---\\[6.792201ms\\] com.UserServiceImpl:get() +---\\[0.008ms\\] com.UserServiceImpl:check() #17 +---\\[0.076ms\\] com.UserServiceImpl:service() #18 +---\\[0.1089ms\\] com.UserServiceImpl:redis() #19 \\&#96;---\\[6.528899ms\\] com.UserServiceImpl:mysql() #20 4.9.2 统计方法耗时使用 monitor 命令监控统计方法的执行情况。 每 5 秒统计一次 com.UserServiceImpl 类的 get 方法执行情况。 1monitor -c 5 com.UserServiceImpl get 4.10 想观察方法信息下面的示例用到了文章的前两个模拟代码。 4.10.1 观察方法的入参出参信息使用 watch 命令轻松查看输入输出参数以及异常等信息。 12345678910111213141516171819202122232425262728USAGE: watch \\[-b\\] \\[-e\\] \\[-x &lt;value&gt;\\] \\[-f\\] \\[-h\\] \\[-n &lt;value&gt;\\] \\[-E\\] \\[-M &lt;value&gt;\\] \\[-s\\] class-pattern method-pattern express \\[condition-express\\] SUMMARY: Display the input&#x2F;output parameter, return object, and thrown exception of specified method invocation The express may be one of the following expression (evaluated dynamically): target : the object clazz : the object&#39;s class method : the constructor or method params : the parameters array of method params\\[0..n\\] : the element of parameters array returnObj : the returned object of method throwExp : the throw exception of method isReturn : the method ended by return isThrow : the method ended by throwing exception #cost : the execution time in ms of method invocation Examples: watch -b org.apache.commons.lang.StringUtils isBlank params watch -f org.apache.commons.lang.StringUtils isBlank returnObj watch org.apache.commons.lang.StringUtils isBlank &#39;&#123;params, target, returnObj&#125;&#39; -x 2 watch -bf \\*StringUtils isBlank params watch \\*StringUtils isBlank params\\[0\\] watch \\*StringUtils isBlank params\\[0\\] params\\[0\\].length&#x3D;&#x3D;1 watch \\*StringUtils isBlank params &#39;#cost&gt;100&#39; watch -E -b org\\\\.apache\\\\.commons\\\\.lang\\\\.StringUtils isBlank params\\[0\\] WIKI: https:&#x2F;&#x2F;alibaba.github.io&#x2F;arthas&#x2F;watch 常用操作： 12345678\\# 查看入参和出参$ watch com.Arthas addHashSet &#39;&#123;params\\[0\\],returnObj&#125;&#39;# 查看入参和出参大小$ watch com.Arthas addHashSet &#39;&#123;params\\[0\\],returnObj.size&#125;&#39;# 查看入参和出参中是否包含 &#39;count10&#39;$ watch com.Arthas addHashSet &#39;&#123;params\\[0\\],returnObj.contains(&quot;count10&quot;)&#125;&#39;# 查看入参和出参，出参 toString$ watch com.Arthas addHashSet &#39;&#123;params\\[0\\],returnObj.toString()&#125;&#39; 查看入参出参。 查看返回的异常信息。 4.10.2 观察方法的调用路径使用 stack 命令查看方法的调用信息。 12\\# 观察 类com.UserServiceImpl的 mysql 方法调用路径stack com.UserServiceImpl mysql 4.10.3 方法调用时空隧道使用 tt 命令记录方法执行的详细情况。 tt 命令方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测 。 常用操作： 开始记录方法调用信息：tt -t com.UserServiceImpl check 可以看到记录中 INDEX=1001 的记录的 IS-EXP = true ，说明这次调用出现异常。 查看记录的方法调用信息： tt -l 查看调用记录的详细信息（-i 指定 INDEX）： tt -i 1001 可以看到 INDEX=1001 的记录的异常信息。 重新发起调用，使用指定记录，使用 -p 重新调用。 1tt -i 1001 -p 文中代码已经上传到 Github。 https://github.com/niumoo/lab-notes/tree/master/src/main/java/net/codingme/arthas &lt;完&gt;个人网站：https://www.codingme.net如果你喜欢这篇文章，可以关注公众号，一起成长。关注公众号回复资源可以没有套路的获取全网最火的的 Java 核心知识整理 &amp; 面试核心资料。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-09-17T02:01:29.016Z","updated":"2020-09-17T02:01:29.016Z","comments":true,"path":"2020/09/17/hello-world/","link":"","permalink":"http://example.com/2020/09/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}